// Gitflow rules
ext {
    branch = getBranch()
    branchType = (branch =~ /([^\/]+)/)[0][1]
    nexusDeployTarget = getDeployTarget(branch)
    isSnapshotVersion = project.version.endsWith('-SNAPSHOT')
}

def getBranch() {
    def branch = new ByteArrayOutputStream()
    exec {
        commandLine "git", "rev-parse", "--abbrev-ref", "HEAD"
        standardOutput = branch
    }

    return branch.toString().trim()
}

def getDeployTarget(branch) {
    switch (branch) {
        case ~/^(master)/:
            return 'releases'
        case ~/^(release.*|hotfix.*)/:
            return 'staging'
        case ~/^(develop)/:
            return 'snapshots'
        default:
            return 'none'
    }
}

// Fail the build if the version is not compatible with the branch type, for example:
// master must be a release version, i.e. non-SNAPSHOT
// release must be a release version, i.e. non-SNAPSHOT and branch name pattern matches version
// hotfix must be a release version, i.e. non-SNAPSHOT and branch name pattern matches version
// everything except master, release and hotfix must be a SNAPSHOT version
if (branchType == "master" || branchType == "release" || branchType == "hotfix") {
    if (isSnapshotVersion) {
        throw new GradleException("\n*** GIT branch [$branch] is not allowed to publish a SNAPSHOT version ***")
    }
} else {
    if (!isSnapshotVersion) {
        throw new GradleException("\n*** GIT branch [$branch] is not allowed to publish a RELEASE version ***")
    }
}
if ((branchType == "release" || branchType == "hotfix") && branch != branchType + "/" + version) {
    throw new GradleException("\n*** GIT branch [$branch] version does not match gradle version [$version] ***")
}

// Disable publishing the jar and docker image to maven if we are building a version not destined
// for a nexus repo, for example, a feature or bugfix branch
if (nexusDeployTarget == "none") {
    dockerPush.onlyIf { false }
    publish.onlyIf { false }
    // Task publishMavenJavaPublicationToMavenRepository is added dynamically during the
    // configuration phase. Disable it with the following closure
    tasks.whenTaskAdded { task ->
        if (task.name == "publishMavenJavaPublicationToMavenRepository") {
            task.onlyIf { false }
        }
    }
}

// Master branch specific processing
if (branchType == "master") {
    // Disable any build related tasks not related to publishing
    afterEvaluate { project ->
        project.tasks.collect { task ->
            if (task.name != "clean"
                    && !task.name.startsWith("publish")
                    && !task.name.startsWith("dockerPrepare")
                    && !task.name.startsWith("dockerPush")
                    && !task.name.startsWith("gitflow")) {
                task.onlyIf { false }
            }
        }
    }

    // Download the pre-built jar artifact from Nexus staging
    task gitflowDownloadJarArtifactFromStaging() {
        publish.dependsOn tasks.gitflowDownloadJarArtifactFromStaging

        doLast {
            // Define the dependencies configuration ignoring all transitive dependencies, i.e. we only
            // require the actual uber jar that has been pre-built and deployed into Nexus staging
            configurations {
                staging { transitive = false }
            }

            // Gradle will not resolve the artifact from Nexus if the artifact is built by this module,
            // i.e. the group, name and version we need to download matches the group, name and version of
            // this module. To overcome this restriction, we will 'hide' this group name from gradle to
            // fool it into allowing us to download the pre-built artifact from Nexus
            def actualProjectGroup=project.group
            project.group = "hidden"

            // Define the pre-built artifact to download from Nexus staging
            dependencies {
                staging("$actualProjectGroup:$project.name:$project.version") { changing = true }
            }

            copy {
                from configurations.staging
                into "$buildDir/libs"
            }

            // Unhide the group name
            project.group=actualProjectGroup
        }
    }

    // Download the pre-built docker image from Nexus staging and tag it as the correct name ready to publish
    task gitflowDownloadDockerArtifactFromStaging() {
        dockerPush.dependsOn tasks.gitflowDownloadDockerArtifactFromStaging

        doLast {
            exec {
                commandLine "docker", "pull", "$nexusHost:8084/${jar.baseName}:${project.version}"
            }
            exec {
                commandLine "docker", "tag", "$nexusHost:8084/${jar.baseName}:${project.version}", "$nexusHost:8085/${jar.baseName}:${project.version}"
            }
        }
    }

    // Tag the version
    task gitflowTag(dependsOn: publish) {
        publish.finalizedBy gitflowTag

        doLast {
            exec {
                commandLine "git", "tag", "--force", "--annotate", "$version", "--message", "$version"
            }
            exec {
                commandLine "git", "push", "--force", "--tags"
            }
        }
    }
}